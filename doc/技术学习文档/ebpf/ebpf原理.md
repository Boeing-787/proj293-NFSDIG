BCC是基于eBPF的工具集合，它允许用户编写eBPF程序来跟踪内核和用户空间的事件。而bpftrace是一个更高级的脚本工具，语法类似AWK，适合快速编写单行命令或短脚本进行跟踪。
- **快速诊断**：使用`bpftrace`编写简短脚本或单行命令。
    
- **复杂分析**：使用BCC的预置工具（如`filetop`、`biolatency`）。
    
- **全面性能剖析**：结合`perf`和`ftrace`进行多维度分析。
    
- **压测验证**：用`fio`模拟负载，验证文件系统性能


##  Fault-Analysis-of-NFS-File-System-Based-on-eBPF
> 本项目拟基于 C  实现项目在用户端的语言，将会使用到 libbpf C/C++ library。

+ BCC 是一个框架，它允许用户编写 python 程序，并将 eBPF 程序嵌入其中。该框架主要用于应用程序和系统的分析/跟踪等场景，其中 eBPF 程序用于收集统计数据或生成事件，而用户空间中的对应程序收集数据并以易理解的形式展示。运行 python 程序将生成 eBPF 字节码并将其加载到内核中。

+ bpftrace 是一种用于 Linux eBPF 的高级跟踪语言，可在较新的 Linux 内核（4.x）中使用。bpftrace 使用 LLVM 作为后端，将脚本编译为 eBPF 字节码，并利用 BCC 与 Linux eBPF 子系统以及现有的 Linux 跟踪功能（内核动态跟踪（kprobes）、用户级动态跟踪（uprobes）和跟踪点）进行交互。bpftrace 语言的灵感来自于 awk、C 和之前的跟踪程序，如 DTrace 和 SystemTap

+ libbpf 库是一个基于 C/ c++ 的通用 eBPF 库，它可以帮助解耦将 clang/LLVM 编译器生成的 eBPF 对象文件的加载到内核中的这个过程，并通过为应用程序提供易于使用的库 API 来抽象与 BPF 系统调用的交互。

+ eBPF Go 语言库提供了一个通用的 eBPF 库，它将获取 eBPF 字节码的过程与 eBPF 程序的加载和管理进行了解耦。eBPF 程序通常是通过编写高级语言，然后使用 clang/LLVM 编译器编译成 eBPF 字节码来创建的

bpftrace在编写短小脚本方面具有优势，而BCC则更适合开发复杂逻辑和作为后台程序。它们都是基于libbpf构建。
![[Pasted image 20250219112247.png]]

### knowledge
1. 实际上，我们通常用带宽、吞吐量、延时、PPS（Packet Per Second）等指标衡量网络的性能。
2. 除了这些指标，网络的可用性（网络能否正常通信）、并发连接数（TCP 连接数量）、丢包率（丢包百分比）、重传率（重新传输的网络包比例）等也是常用的性能指标。

## BCC & eBPF
eBPF 有诸多前端工具，如 bcc，bpftrace，libbpf C/C++ library。

### CO-RE：
它允许 eBPF 程序包含编译时的数据结构体布局信息，并提供了一种机制，用于在目标机器上运行时，如果数据结构体布局不同，就调整字段的访问方式。只要程序不访问目标机器内核中根本不存在的字段或数据结构体，程序就可以在不同内核版本之间移植。

+ BTF: 一种表达数据结构体和函数签名布局的格式。
+ 内核头：Linux 内核源代码包含描述其使用的数据结构体的头文件
+ 编译器支持：[Clang 编译器得到了增强](https://lists.llvm.org/pipermail/cfe-dev/2021-December/069635.html)，因此当它使用 **-g** 标志编译 eBPF 程序时，它包括所谓的 _CO-RE 重定位_，该重定位源自描述内核数据结构体的 BTF 信息。
+ 支持数据结构体重定位的库： libbpf， Clilium, Aya
+ BPF 框架（skeleton）

### BTF
 BTF 描述数据结构和函数的格式。用 C 编写的 eBPF 程序需要定义类型和结构体的头文件。
 
eBPF 程序需要它所引用的任何内核数据结构体和类型的定义。在 CO-RE 出现之前，您通常必须弄清楚 Linux 内核源代码中的许多单独头文件中的哪些包含您感兴趣的结构的定义，但现在有一种更简单的方法，因为支持 BTF 的工具可以从内核包含的 BTF 信息中生成一个合适的头文件。当程序在目标计算机上运行时，将其加载到内核的用户空间程序将根据编译时的 BTF 信息和目标机器上运行的内核的 BTF 信息之间的差异进行调整。
>bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h

### 程序类型
所有的 eBPF 程序都接受一个指针作为上下文参数，但它所指向的结构体取决于触发该程序的事件类型。eBPF 程序员需要编写接受适当类型上下文的程序；eBPF 程序员有需求能够在 eBPF 程序中访问一些内部函数。这可以通过一种称为 BPF 内核函数或 [kfuncs](https://docs.kernel.org/bpf/kfuncs.html) 的机制实现。总而言之，eBPF 程序的类型决定了它可以附加到哪些事件上，进而定义了它所接收的上下文信息的类型。程序类型还定义了它可以调用的辅助函数和 kfuncs 的集合。

程序类型广泛地可分为两类：跟踪（tracing）（或性能（perf））程序类型和与网络相关的程序类型。

#### eBPF挂钩机制

- ==‌**BPF_PROG_TYPE_PERF_EVENT**‌==：通过`perf_event_open()`挂载BPF程序到硬件/软件事件（如CPU周期、缓存未命中）‌6。
- ==‌**BPF_TRACE_FENTRY**‌==：依赖`fentry_can_attach()`验证函数原型，实现低开销函数入口追踪‌5。
## 性能分析

### Principle
1. 当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了。-- uptime


### tools:
2. stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。
3. sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。
	1. mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。
	2. pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。
4. vmstat 这个工具，来查询系统的上下文切换情况。
5. 使用 sysbench 来模拟系统多线程调度切换的情况。sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况。
6. perf 是 Linux 2.6.31 以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。
	1. 第一种常见用法是 perf top，类似于 top，它能够实时显示占用 CPU 时钟最多的函数或者指令，因此可以用来查找热点函数。
	2. 第一种常见用法是 perf top，类似于 top，它能够实时显示占用 CPU 时钟最多的函数或者指令，因此可以用来查找热点函数。
	3. 在实际使用中，我们还经常为 perf top 和 perf record 加上 -g 参数，开启调用关系的采样，方便我们根据调用链来分析性能问题。
7. ab（apache bench）是一个常用的 HTTP 服务性能测试工具
8. execsnoop 就是一个专为短时进程设计的工具。它通过 ftrace 实时监控进程的 exec() 行为，并输出短时进程的基本信息，包括进程 PID、父进程 PID、命令行参数以及执行的结果。
9. dstat 是一个新的性能工具，它吸收了 vmstat、iostat、ifstat 等几种工具的优点，可以同时观察系统的 CPU、磁盘 I/O、网络以及内存使用情况
10. sar:
	1. 指标：rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包 / 秒。rxkB/s 和 txkB/s 分别是接收和发送的吞吐量，单位是 KB/ 秒。rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包 / 秒。%ifutil 是网络接口的使用率，即半双工模式下为(rxkB/s+txkB/s)/Bandwidth，而全双工模式下为 max(rxkB/s, txkB/s)/Bandwidth。



### knowledge:
11. /proc 实际上是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。/proc/interrupts 就是这种通信机制的一部分，提供了一个只读的中断使用情况。
12. 为了维护 CPU 时间，Linux 通过事先定义的节拍率（内核中表示为 HZ），触发时间中断，并使用全局变量 Jiffies 记录了开机以来的节拍数。每发生一次时间中断，Jiffies 的值就加 1。节拍率 HZ 是内核的可配选项，可以设置为 100、250、1000 等。不同的系统可能设置不同数值，你可以通过查询 /boot/config 内核选项来查看它的配置值。

### 综合思路
一个好的监控系统，不仅可以实时暴露系统的各种问题，更可以根据这些监控到的状态，自动分析和定位大致的瓶颈来源，从而更精确地把问题汇报给相关团队处理。要做好监控，最核心的就是全面的、可量化的指标，这包括系统和应用两个方面。
+ 从系统来说，监控系统要涵盖系统的整体资源使用情况，比如我们前面讲过的 CPU、内存、磁盘和文件系统、网络等各种系统资源。
+ 而从应用程序来说，监控系统要涵盖应用程序内部的运行状态，这既包括进程的 CPU、磁盘 I/O 等整体运行状况，更需要包括诸如接口调用耗时、执行过程中的错误、内部对象的内存使用等应用程序内部的运行状况。

USE法：
USE 法把**系统**资源的性能指标，简化成了三个类别，即使用率、饱和度以及错误数。
+ 使用率，表示资源用于服务的时间或容量百分比。100% 的使用率，表示容量已经用尽或者全部时间都用于服务。
+ 饱和度，表示资源的繁忙程度，通常与等待队列的长度相关。100% 的饱和度，表示资源无法接受更多的请求。
+ 错误数表示发生错误的事件个数。错误数越多，表明系统的问题越严重。
常见系统性能指标（USE）
![[Pasted image 20250217110219.png]]
掌握 USE 方法以及需要监控的性能指标后，接下来要做的，就是建立监控系统，把这些指标保存下来；

然后，根据这些监控到的状态，自动分析和定位大致的瓶颈来源；

最后，再通过告警系统，把问题及时汇报给相关团队处理。

可以看出，一个完整的监控系统通常由**数据采集、数据存储、数据查询和处理、告警以及可视化展示**等多个模块组成。

### existed Tools:
Zabbix、Nagios、Prometheus
Prometheus系统架构：
![[Pasted image 20250217110912.png]]

应用监控指标：**请求数、错误率和响应时间**。另外还有以下一些：
+ 应用进程的资源使用情况，比如进程占用的 CPU、内存、磁盘 I/O、网络等。使用过多的系统资源，导致应用程序响应缓慢或者错误数升高，是一个最常见的性能问题。
+ 应用程序之间调用情况，比如调用频率、错误数、延时等。
+ 应用程序内部核心逻辑的运行情况，比如关键环节的耗时以及执行过程中的错误等。
由于业务系统通常会涉及到一连串的多个服务，形成一个复杂的分布式调用链。为了迅速定位这类跨应用的性能瓶颈，你还可以使用 Zipkin、Jaeger、Pinpoint 等各类开源工具，来构建全链路跟踪系统。

同样的一个接口，当请求传入的参数不同时，就可能会导致完全不同的性能问题。所以，除了指标外，我们还需要对这些指标的上下文信息进行监控，而日志正是这些上下文的最佳来源。

对日志监控来说，最经典的方法，就是使用 **ELK 技术栈**，即使用 Elasticsearch、Logstash 和 Kibana 这三个组件的组合。



### 瓶颈分析：
##### 系统瓶颈分析
CPU瓶颈分析：
![[Pasted image 20250217114429.png]]
内存瓶颈分析：
![[Pasted image 20250217114448.png]]
IO瓶颈分析：
![[Pasted image 20250217114507.png]]
网络性能分析：
![[Pasted image 20250217114524.png]]
##### 应用程序性能问题
虽然各种各样，但就其本质来源，实际上只有三种，也就是资源瓶颈、依赖服务瓶颈以及应用自身的瓶颈

### 优化思路

##### CPU优化
CPU 性能优化的核心，在于排除所有不必要的工作、充分利用 CPU 缓存并减少进程调度对性能的影响。
+ 第一种，把进程绑定到一个或者多个 CPU 上，充分利用 CPU 缓存的本地性，并减少进程间的相互影响。
+ 第二种，为中断处理程序开启多 CPU 负载均衡，以便在发生大量中断时，可以充分利用多 CPU 的优势分摊负载。
+ 第三种，使用 Cgroups 等方法，为进程设置资源限制，避免个别进程消耗过多的 CPU。同时，为核心应用程序设置更高的优先级，减少低优先级任务的影响。

内存优化， IO优化，网络优化

### 性能工具速查
![[Pasted image 20250217154113.png]]
![[Pasted image 20250217154337.png]]
![[Pasted image 20250217154359.png]]
![[Pasted image 20250217154410.png]]
![[Pasted image 20250217154421.png]]
![[Pasted image 20250217154511.png]]
在定位性能问题时，我们通过 perf、ebpf、systemtap 等各种方法排查时，很可能会发现，问题的热点在内核中的某个函数中。而青石和 xfan 的问题，就是如何去了解、深入 Linux 内核的原理，特别是想弄清楚，性能工具展示的内核函数到底是什么含义。其实，要了解内核函数的含义，最好的方法，就是去查询所用内核版本的源代码。这里，我推荐 https://elixir.bootlin.com 这个网站。使用方法也很简单，从左边选择内核版本，再通过内核函数名称去搜索就可以了




