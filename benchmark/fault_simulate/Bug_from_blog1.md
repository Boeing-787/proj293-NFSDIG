这是一个非常有趣且典型的“**看似是客户端问题，实则是服务器端限制暴露在协议差异下的 NFS 诡异行为**”案例。我们来深入分析这个 bug 的本质、原因、触发机制以及背后的协议设计差异。
https://blog.dend.ro/a-fun-nfs-bug/
---

## 🐞 Bug 概述

- **现象**：
  - 同一个文件，**只能被打开一次**。
  - 第二次尝试打开同一文件（无论是否来自同一进程、不同进程、甚至不同客户端）都会失败，返回 `EPERM`（Operation not permitted）。
  - 一旦第一个文件描述符关闭，再次打开又恢复正常。
  - **仅在使用 NFSv4 时出现，NFSv3 正常**。
  - 应用表现不一：老版本 GDAL 多次打开文件 → 失败；新版本只打开一次 → 成功。

- **根本原因**：
  > **NFS 服务器端错误地将 `NFS4ERR_PERM` 返回给合法的文件打开请求**，且该行为与 NFSv4 的状态模型（state model）和身份验证机制有关。

---

## 🔍 一、关键线索解析

### 1. `strace` 输出揭示核心问题

```text
open("/mount_nfs/path/to/file.jp2", O_RDONLY) = 3     # 第一次成功
...
open("/mount_nfs/path/to/file.jp2", O_RDONLY) = -1 EPERM  # 第二次失败
```

- `EPERM` 在 Linux 系统调用中通常映射为 NFS 协议中的 `NFS4ERR_PERM`。
- `NFS4ERR_PERM` 的语义是：
  > “**调用者不是文件所有者，也不是特权用户（如 root）**”，因此不允许执行该操作。
- 注意：它**不同于 `NFS4ERR_ACCESS`**，后者是“权限不足”（如无读权限），而 `NFS4ERR_PERM` 更强调“身份不符”。

### 2. Python 实验确认行为模式

```python
f1 = open(...)  # 成功
f2 = open(...)  # 失败 → EPERM
f1.close()
f2 = open(...)  # 成功
```

✅ 表明：
- 并非文件本身权限问题（否则第一次也打不开）。
- 是某种**服务器端的并发或状态限制**。
- 与“是否已有打开句柄”强相关。

---

## 🧩 二、NFSv3 vs NFSv4 的关键差异

这是理解此 bug 的核心。

| 特性 | NFSv3 | NFSv4 |
|------|-------|--------|
| **无状态（Stateless）** | ✅ 服务器不维护客户端状态 | ❌ |
| **有状态（Stateful）** | ❌ | ✅ 支持文件锁、打开状态等 |
| **OPEN 操作** | 简单的文件访问 | 创建“打开状态”（open state） |
| **身份映射** | 依赖 `uid/gid`，较简单 | 强依赖 `principal`、`owner`、`machine user` 等 |
| **安全性** | 基于 IP + uid/gid（不安全） | 支持 Kerberos、RPCSEC_GSS 等 |

### 🎯 问题出在 NFSv4 的“打开状态”管理

在 NFSv4 中：
- 当客户端 `OPEN` 一个文件时，服务器会创建一个“打开状态”（open state），并与客户端的 **`clientid`** 和 **`owner`** 关联。
- 后续对该文件的操作（包括再次打开）需要符合状态一致性。
- 服务器必须正确判断：**“同一个客户端再次打开” vs “不同用户/客户端打开”**。

---

## ⚠️ 三、服务器端的错误逻辑（推测）

结合 `NFS4ERR_PERM` 和“只能打开一次”的行为，可以推断：

> **该 NFS 网关服务器在处理 NFSv4 的第二次 `OPEN` 请求时，错误地认为这是一个“非所有者用户的重复打开”，并拒绝了请求。**

可能的错误逻辑：

```c
// 伪代码：错误的 NFSv4 OPEN 处理逻辑
if (file_already_open_by_someone) {
    if (current_user != file_owner && !is_privileged_user) {
        return NFS4ERR_PERM;  // 错误！应该允许同一用户/客户端再次打开
    }
}
```

但事实上：
- 即使不是文件所有者，**只要权限允许（如 world-readable）**，也应该能打开文件。
- NFSv4 允许多次打开同一个文件（就像本地文件系统一样）。
- 服务器混淆了“权限检查”和“所有权检查”。

---

## ✅ 四、为什么 NFSv3 能正常工作？

- NFSv3 是**无状态协议**，`open()` 被映射为简单的 `LOOKUP + ACCESS`。
- 每次 `open()` 都是独立操作，服务器只检查：
  - 文件是否存在？
  - 调用者的 `uid/gid` 是否有读权限？
- 不维护“打开状态”，因此不存在“第二次打开被拒”的逻辑。
- 所以即使服务器身份逻辑有问题，NFSv3 的简单模型绕过了这个问题。

---

## 🛠️ 五、解决方案分析

### ✅ 当前 workaround：使用 `nfsvers=3`

```bash
mount -t nfs -o nfsvers=3 server:/path /mount
```

- **优点**：简单有效，绕开有问题的 NFSv4 实现。
- **缺点**：
  - 失去 NFSv4 的优势：无状态、无文件锁、性能略低。
  - 安全性更弱（依赖 `uid/gid` 映射）。
  - 不支持大文件（>2GB）的某些特性（虽然现代内核已修复）。

### 🛑 为什么服务器不修复？

- 该问题出在 **NFS 网关服务器的实现**（可能是基于某个开源网关如 `nfs-ganesha` 或自研）。
- 云厂商可能未正确实现 NFSv4 的 `OPEN` 状态管理。
- 作者早在 2020 年就报告过，但厂商未修复 → 可能是边缘 case 或优先级低。

---

## 📌 六、总结与启示

| 项目 | 说明 |
|------|------|
| **Bug 类型** | 协议层逻辑错误（服务器端） |
| **触发条件** | NFSv4 + 多次打开同一文件 |
| **根本原因** | 服务器错误地将 `NFS4ERR_PERM` 返回给合法的第二次 `OPEN` 请求 |
| **影响** | 多数打开文件多次的应用（如老版 GDAL、编辑器、备份工具）会失败 |
| **修复方式** | 客户端降级到 NFSv3，或服务器修复 NFSv4 实现 |
| **关键洞见** | `NFS4ERR_PERM` ≠ `NFS4ERR_ACCESS`，前者是身份问题，后者是权限问题 |

---

## 🎯 一句话总结

> 这个“fun little bug”揭示了一个 **NFSv4 网关服务器的身份验证逻辑缺陷**：它错误地认为“非所有者用户不能多次打开一个文件”，导致返回 `NFS4ERR_PERM`；而 NFSv3 因其无状态特性天然规避了这个问题，从而提供了一个简单有效的 workaround。

---

## 💡 给开发者的建议

1. **遇到奇怪的 `EPERM`？优先检查是否是 `NFS4ERR_PERM` 而非 `EACCES`**。
2. **多用 `strace` 和 `tcpdump`**：`strace` 定位系统调用失败，`tcpdump` 查看 NFS 协议层错误码。
3. **NFSv4 不是 NFSv3 的简单升级**：它引入了状态、安全、锁等复杂性，服务器实现必须完整支持。
4. **云服务的 NFS 网关可能不完善**：特别是 S3-to-NFS 网关，可能只实现了“基本读写”，忽略了协议细节。

---

> 📢 最后，向作者致敬：用 `strace` + Python 快速定位问题，并分享给社区，这才是真正的“debugging art”。