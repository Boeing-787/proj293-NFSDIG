这是一个关于 **Linux 内核 NFS 客户端 `noresvport` 选项在 NFSv4 上失效** 的严重回归问题。你的初步分析非常精准，问题确实出现在内核 5.12 版本的 NFS 子系统更新中。
[Bug报告链接](https://bugzilla.kernel.org/show_bug.cgi?id=215526)
---

## 🐞 Bug 概述

*   **现象**：
    1.  使用 `mount -o vers=4.2,noresvport server:/export /mnt` 挂载 NFSv4 共享。
    2.  预期：NFS 客户端应使用**非特权端口**（端口号 >= 1024）与服务器通信。
    3.  实际：客户端**仍然使用特权端口**（端口号 < 1024）进行连接。
    4.  对比：使用 `vers=3,noresvport` 时，行为正常，客户端使用非特权端口。

*   **关键点**：
    - 该问题**仅影响 NFSv4**（v4.0, v4.1, v4.2）。
    - 该问题是一个**内核回归**（Regression），在 **5.11.11 版本工作正常，5.12.19 版本开始失效**。
    - 你的初步 bisect 指向 `nfs-for-5.12-2` 这个提交集非常准确。

---

## 🔍 一、问题的根源：NFSv4 回调通道（Callback Channel）与 `bindresvport()`

### 1. NFSv4 的回调机制（Callback）

NFSv4 与 NFSv3 的一个关键区别是引入了**有状态**和**回调**（Callback）机制。服务器需要一种方式能主动联系客户端（例如，当文件锁需要回收时）。

*   **客户端角色**：客户端在启动 NFSv4 会话时，必须告知服务器：“如果需要回调我，请连接到我的 IP 地址和某个端口”。
*   **这个“告知”的端口**，就是 **NFSv4 回调通道**（通常监听在 TCP 2049 或一个随机端口）。

### 2. `noresvport` 选项的本意

*   `noresvport` 选项的目的是让 NFS 客户端**避免使用特权端口**（< 1024），因为绑定到这些端口通常需要 `CAP_NET_BIND_SERVICE` 能力（通常是 root 权限）。
*   在 NFSv3 中，客户端主要是**发起**连接，`noresvport` 控制的是**发起连接时使用的源端口**。
*   在 NFSv4 中，`noresvport` 还应控制**回调通道监听端口**的选择。

### 3. Bug 的根本原因

> **在内核 5.12 的某个 NFS 更新中，处理 NFSv4 回调通道绑定逻辑的代码，忽略了 `noresvport` 选项，导致在创建回调监听套接字时，仍然调用了 `bindresvport()` 或等效函数，强制绑定到一个特权端口。**

*   **为什么 NFSv3 不受影响？** NFSv3 没有复杂的回调机制，`noresvport` 只控制客户端发起连接的源端口，这部分逻辑未被破坏。
*   **为什么你的 bisect 指向 `nfs-for-5.12-2`？** 这个提交集包含了对 NFSv4 初始化和连接逻辑的多项修复和重构。其中某个改动（很可能是与 `nfs4_init_client()` 或 `nfs_callback_up()` 相关的代码）在处理回调通道创建时，未能正确传递或检查 `noresvport` 标志。

---

## 📌 二、为什么这是一个严重问题？

1.  **安全策略冲突**：许多企业防火墙或安全组规则明确禁止非特权进程使用特权端口，或对特权端口流量进行严格监控。`noresvport` 是绕过这些限制的标准方法，现在失效了。
2.  **容器化环境问题**：在容器中，默认情况下进程没有绑定特权端口的权限。即使使用 `noresvport`，如果内核内部仍尝试绑定特权端口，会导致 NFSv4 挂载失败或行为异常。
3.  **与预期不符**：管理员明确指定了 `noresvport`，期望客户端行为一致（无论 v3 或 v4），但内核未能遵守。

---

## ✅ 三、解决方案与建议

### ✅ 1. Workaround（临时规避）

*   **使用 NFSv3**：如果环境允许，降级到 `vers=3`。`vers=3,noresvport` 依然可靠工作。
    ```bash
    mount -t nfs -o vers=3,noresvport server:/export /mnt
    ```
*   **手动指定源端口**：使用 `port=` 和 `mountport=` 选项显式指定非特权端口（但这通常用于挂载端口，对回调通道帮助有限）。
*   **调整防火墙规则**：如果可能，放宽对客户端机器上 NFS 相关特权端口的限制（不推荐，降低安全性）。

### 🛠️ 2. 根本修复（内核补丁）

需要在内核的 NFSv4 回调初始化代码中，正确处理 `noresvport` 选项。

**修复方向**：

1.  在 `fs/nfs/nfs4callback.c` 或 `fs/nfs/nfs4client.c` 中，找到创建回调监听套接字的函数（如 `nfs_callback_tcp_listen()` 或类似）。
2.  确保在调用 `bind()` 或 `bindresvport()` 之前，检查挂载选项中的 `noresvport` 标志。
3.  如果设置了 `noresvport`，则：
    *   **不要调用 `bindresvport()`**。
    *   使用 `bind()` 绑定到一个**随机的非特权端口**（例如，让内核自动选择一个 >= 1024 的端口）。
    *   或者，绑定到一个明确指定的非特权端口。

**伪代码示意**：

```c
// 修复前（错误）：
int create_callback_socket(struct nfs_client *clp) {
    ...
    // 无论 noresvport 是否设置，都尝试绑定特权端口
    if (bindresvport_us(resv_sock, NULL) < 0)
        goto out_err;
    ...
}

// 修复后（正确）：
int create_callback_socket(struct nfs_client *clp) {
    ...
    if (test_bit(NFS_CS_NO_RESVPORT, &clp->cl_resvport)) {
        // noresvport 设置了：绑定到随机非特权端口
        // 或者绑定到一个预定义的非特权端口
        struct sockaddr_in addr = { .sin_port = 0 }; // 0 表示随机
        if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0)
            goto out_err;
    } else {
        // 否则，尝试绑定特权端口
        if (bindresvport_us(resv_sock, NULL) < 0)
            goto out_err;
    }
    ...
}
```

---

## 📊 四、总结

| 项目 | 说明 |
| :--- | :--- |
| **Bug 类型** | Linux 内核 NFSv4 客户端回归 (Regression) |
| **触发条件** | `mount -o vers=4.x,noresvport ...` |
| **根本原因** | NFSv4 回调通道（Callback Channel）在创建监听套接字时，忽略了 `noresvport` 选项，错误地尝试绑定到特权端口。 |
| **影响范围** | Linux 内核 5.12 及更高版本。RHEL8/CentOS 8, Fedora 等使用较新内核的发行版受影响。 |
| **Workaround** | 使用 `vers=3,noresvport`。 |
| **根本修复** | 修改内核 NFSv4 回调初始化代码，根据 `noresvport` 标志决定是否使用 `bindresvport()`。 |
| **核心教训** | 1. **回归测试的重要性**：NFS 子系统的复杂变更需要充分的回归测试，特别是对向后兼容性关键的选项。<br>2. **回调通道的特殊性**：NFSv4 的回调机制引入了客户端作为服务端的新角色，其端口选择策略必须与主连接保持一致。<br>3. **用户预期**：明确的挂载选项（如 `noresvport`）必须被严格遵守，无论协议版本。 |

---

> 📢 **一句话总结**：这个 bug 的本质是内核 5.12 中 NFSv4 回调通道的实现，未能尊重 `noresvport` 挂载选项，导致客户端在建立回调监听时错误地使用了特权端口。这破坏了依赖非特权端口的安全策略。最有效的临时方案是降级到 NFSv3，而彻底解决需要内核开发者修复回调初始化逻辑，使其正确响应 `noresvport` 标志。