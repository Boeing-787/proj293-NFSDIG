## 描述
这个 bug 修复的核心是：**修正了 NFS 客户端访问权限缓存（access cache）的时间戳初始化时机问题，防止因时间戳未正确设置导致缓存频繁失效，从而避免大量不必要的 ACCESS 请求发送到服务器。**

---

### 🐞 **Bug 问题概括**

- **现象**：
  - NFS 客户端在用户登录后，**访问权限缓存（access cache）可能过早或错误地失效**。
  - 导致客户端频繁向服务器发送 `ACCESS` 请求来检查权限，**显著增加网络和服务器负载**。

- **根本原因**：
  - 当用户登录时，NFS 客户端会检查是否已存在该用户的缓存条目（在 RB-tree 中）。
  - **仅当条目不存在时，才会设置缓存时间戳**。
  - 如果条目已存在（比如用户之前登录过），**时间戳未被更新，可能为 0 或旧值**。
  - 由于判断缓存是否过期依赖于这个时间戳，**时间戳异常会导致缓存被认为“已过期”或“比登录时间还早”**，从而被错误地清除。

> 🔥 结果：即使用户组权限没有变化，也会频繁触发 `ACCESS` 检查。

---


## 复现方法
Assuming the NFS is mounted at /mnt/nas, mount it, time how long it takes to ls -la a directory with a few dozen or more files, run test.sh, check the ls time again.

If the issue is triggered, the time would be significantly larger and more or less the same as you would get if the share was mounted with noac option. Usually it takes one test.sh run to trigger it, if it's not triggered after 3-5 then it's good.

### ✅ **修复方案**

通过提交 **`21fd9e8700de`** 修复：

> **NFS: Correct timing for assigning access cache timestamp**

- **修复内容**：
  - 修改逻辑，**无论缓存条目是否存在，只要用户重新登录，就更新其访问缓存的时间戳为当前登录时间**。
  - 确保时间戳始终有效且反映最新的登录状态。

- **配套机制（由 `029085b8949f` 提供）**：
  - 引入新机制：**一旦缓存时间戳早于用户的当前登录时间，就立即清除该缓存**。
  - 目的是确保：**用户在服务器上组权限变更后，客户端能及时感知并重新检查权限**。

---

### 🎯 **修复目标**

确保 NFS 客户端：
1. **不会因时间戳缺失或错误导致缓存误失效**（避免过度请求）。
2. **能在用户组权限变更后及时刷新缓存**（保证安全性）。

即：**在“性能”和“权限一致性”之间取得正确平衡**。

---

### 📌 **一句话总结**

> 该修复通过**确保 NFS 访问缓存的时间戳始终在用户登录时被正确设置**，解决了因时间戳未初始化导致缓存频繁错误失效的问题，从而避免了大量冗余的 ACCESS 请求，同时保留了在用户组变更后及时刷新权限的能力。



